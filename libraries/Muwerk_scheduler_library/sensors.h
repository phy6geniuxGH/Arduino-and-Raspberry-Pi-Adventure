#pragma once

#include "platform.h"

namespace ustd {
#define SENSOR_VALUE_INVALID -999999.0

class sensorprocessor {
    /*! sensorprocessor implements an exponential filter that smoothens and
     * throttles raw sensor data.
     *
     * It can be configured by:
     * * size of smoothing interval: larger intervals generate larger averaging
     * and slower response to change
     * * minimum change eps required to generate a new sensor reading, in order
     * to ignore small fluctuations
     * * a time-interval in seconds that generates a new sensor reading
     * regardless of change.
     *
     * This library requires the ustd library (for timeDiff) and requires a
     * <a href="https://github.com/muwerk/ustd/blob/master/README.md">platform
     * define</a>.
     *
     * Example:

    ```{.cpp}
    void setup() {
        // generate a filter that exponentially averages over 10 values,
        // generates a new reading at least every 3600sec (even on no
        // change)
        // and generates a new reading every time, the filter value changes
        // for more than 0.1
        ustd::sensorprocessor mySensor(10,3600,0.1)
    }

    void loop() {
        double rawValue=ReadMyRawSensor();
        double filtered=rawValue;
        if mySensor.filter(&filtered) {
            printf("We got a new, filtered reading: %f\n", filtered);
        } else {
            // no valid new reading, do nothing.
        }
    }
    ```

     */
  public:
    unsigned int noVals = 0;
    unsigned int smoothInterval;
    unsigned int pollTimeSec;
    double sum = 0.0;
    double eps;
    bool first = true;
    double meanVal = 0;
    double lastVal = SENSOR_VALUE_INVALID;
    unsigned long last;

    sensorprocessor(unsigned int smoothInterval = 5,
                    int unsigned pollTimeSec = 60, double eps = 0.1)
        : smoothInterval{smoothInterval}, pollTimeSec{pollTimeSec}, eps{eps} {
        /*! Creates a new sensorprocessor
        @param smoothInterval The size of the interval of sensor value history
        that are being averaged using exponential decay.
        @param pollTimeSec If this is !=0, a valid sensor reading is generated
        at least every pollTimeSec, regardless of value changes.
        @param eps The minimal change required for the smoothed sensor value in
        order to create a new valid reading. Useful for supressing small
        fluctuations.
        */
        reset();
    }

    bool filter(double *pvalue) {
        /*! The sensorprocessor filter function. (double float version)
        @param *pvalue the current raw sensor reading. The filter function uses
        exponential smoothing to filter the value and, if a valid new value is
        available, changes *pvalue.
        @return on true, *pvalue contains a new, smoothed valid sensor reading.
        A new reading is generated by either pollTimeSec (!=0) seconds have been
        passed, or the smoothed value has changed more than espilon eps. A
        return value of false indicates, that no new sensor reading is
        available.
        */
        meanVal = (meanVal * noVals + (*pvalue)) / (noVals + 1);
        if (noVals < smoothInterval) {
            ++noVals;
        }
        double delta = lastVal - meanVal;
        if (delta < 0.0) {
            delta = (-1.0) * delta;
        }
        if (delta > eps || first) {
            first = false;
            lastVal = meanVal;
            *pvalue = meanVal;
            last = millis();
            return true;
        } else {
            if (pollTimeSec != 0) {
                if (timeDiff(last, millis()) > pollTimeSec * 1000L) {
                    *pvalue = meanVal;
                    last = millis();
                    lastVal = meanVal;
                    return true;
                }
            }
        }
        return false;
    }

    bool filter(long *plvalue) {
        /*! The sensorprocessor filter function. (long integer version)
        @param *plvalue the current raw sensor reading. The filter function uses
        exponential smoothing to filter the value and, if a valid new value is
        available, changes *plvalue.
        @return on true, *plvalue contains a new, smoothed valid sensor reading.
        A new reading is generated by either pollTimeSec (!=0) seconds have been
        passed, or the smoothed value has changed more than espilon eps. A
        return value of false indicates, that no new sensor reading is
        available.
        */
        double tval = (double)*plvalue;
        bool ret = filter(&tval);
        if (ret) {
            *plvalue = (long)tval;
        }
        return ret;
    }

    void reset() {
        /*! Delete the filter history */
        noVals = 0;
        sum = 0.0;
        first = true;
        meanVal = 0;
        lastVal = SENSOR_VALUE_INVALID;
        last = millis();
    }
};

}  // namespace ustd
